###AVL树的特点:
AVL树中任何节点的两个子树的高度最大差别为1
###AVL树的性质:
AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct AVLTreeNode{
	int key;
	int height;
	struct AVLTreeNode *left;
	struct AVLTreeNode *right;
}Node, *AVLTree;

#define HEIGHT(n) ( n == NULL ? 0 : (((Node *)(n))->height))
#define MAX(x,y) ((x)>(y) ? (x) : (y))

// 获取AVL树的高度
int avltree_height(AVLTree tree);

// 前序遍历"AVL树"
void preorder_avltree(AVLTree tree);
// 中序遍历"AVL树"
void inorder_avltree(AVLTree tree);
// 后序遍历"AVL树"
void postorder_avltree(AVLTree tree);

void print_avltree(AVLTree tree, int key, int direction);

// (非递归实现)查找"AVL树x"中键值为key的节点
Node* avltree_search(AVLTree x, int key);

// 查找最小结点：返回tree为根结点的AVL树的最小结点。
Node* avltree_minimum(AVLTree tree);
// 查找最大结点：返回tree为根结点的AVL树的最大结点。
Node* avltree_maximum(AVLTree tree);

// 将结点插入到AVL树中，返回根节点
Node* avltree_insert(AVLTree tree, int key);

// 删除结点(key是节点值)，返回根节点
Node* avltree_delete(AVLTree tree, int key);

// 销毁AVL树
void destroy_avltree(AVLTree tree);

// 左左旋转
Node* left_left_rotation(AVLTree tree)
{
	AVLTree tmp;

	tmp= tree->left;
	tree->left = tmp->right;
	tmp->right = tree;

	tree->height = MAX( HEIGHT(tree->left), HEIGHT(tree->right) ) + 1;
	tmp->height = MAX( HEIGHT(tmp->left), HEIGHT(tmp->right) ) + 1;
	return tmp;
}

// 右右旋转
Node* right_right_rotation(AVLTree tree)
{	
	AVLTree tmp;
	tmp = tree->right;
	tree->right = tmp->left;
	tmp->left = tree;

	tree->height = MAX( HEIGHT(tree->left), HEIGHT(tree->right) ) + 1;
	tmp->height = MAX( HEIGHT(tmp->left), HEIGHT(tmp->right) ) + 1;

	return tmp;
}

// 左右旋转
Node* left_right_rotation(AVLTree tree)
{	
	tree->left = right_right_rotation(tree->left);
	return left_left_rotation(tree);
}

// 右左旋转
Node* right_left_rotation(AVLTree tree)
{	
	tree->right = left_left_rotation(tree->right);
	return right_right_rotation(tree);
}


Node* avltree_create_node(int key, Node *left, Node* right)
{
	Node* node = (Node *)malloc(sizeof(Node));

	if (node == NULL)
		return NULL;

	node->height = 0;
	node->left = left;
	node->right = right;
	node->key = key;
	return node;
}

Node* avltree_insert(AVLTree tree, int key)
{
	if (tree == NULL)
	{
		return avltree_create_node(key, NULL, NULL);		
	} 
	else if (key < tree->key)
	{
		tree->left = avltree_insert(tree->left, key);

		if ((HEIGHT(tree->left) - HEIGHT(tree->right)) == 2)
		{
			if (key < tree->left->key)
				tree = left_left_rotation(tree);
			else
				tree = left_right_rotation(tree);
		}
	}
	else if (key > tree->key)
	{
		tree->right = avltree_insert(tree->right, key);
		if ((HEIGHT(tree->right) - HEIGHT(tree->left)) == 2)
		{
			if (key > tree->right->key)
				tree = right_right_rotation(tree);
			else 
				tree = right_left_rotation(tree);
		}
	}
	else 
	{
		return NULL;
	}	
	tree->height = MAX( HEIGHT(tree->left), HEIGHT(tree->right) ) + 1;
	return tree;
}

void print_avltree(AVLTree tree, int key, int direction)
{
	if (tree == NULL)
		return;

	if (direction == 0)
	{
		printf("%d is root\n", tree->key);
	} 
	else
	{
		printf("%d is %s\n", tree->key, direction == 1 ? "left" : "right");
	}
	print_avltree(tree->left, tree->key, 1);
	print_avltree(tree->right, tree->key, -1);
}

int main()
{

	AVLTree root = NULL;

	/*左左旋转*/
	//int arr[] = {14, 12, 15, 11, 13, 10};
	
	/*右右旋转*/
	//int arr[] = {10, 9, 12, 11, 14, 15};

	/*右左旋转*/
	//int arr[] = {10, 9, 14, 13, 15, 12};

	/*左右*/
	int arr[] = {13, 10, 14, 9, 12, 11};
	int len = sizeof(arr)/sizeof(arr[0]);

	for (int i = 0; i<len; i++)
	{
		root = avltree_insert(root, arr[i]);
	}

	print_avltree(root, root->key, 0);

	system("pause");
	return 0;
}

```
